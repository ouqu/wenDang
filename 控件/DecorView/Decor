调用setContent实际上就是调用PhoneWindow.setContentView
第一次调用会构造Decor(继承FrameLayout)，然后inflate一个布局文件，一般这个布局是LinearLayout(vertical，子view有viewStub和FrameLayout), LinearLayout叫contentRoot，里面的FrameLayout叫做contentParent，同时其id是android.R.id.content

对于appcompatv7，获取decorView之后，还会inflate出另一个布局，叫subDecor
然后对subDecor调用makeOptionalFitsSystemWindows，DecorView也有这个flag
然后，会把LinearLayout里的FrameLayout的id改为no_id，subDecor里的FrameLayout获得了android.R.id.content这个id，相当于id转移
调用window.setContentView(subDecor)
最后当你在AppCompatActivity调用setContentView时，实际上你的布局加到了subDecor的android.R.id.content里面。

PhoneWindow在activity的attach方法里构造, 接着创建WindowManager,phoneWindow拿着windowManager，activity则拿着phoneWindow和windowManager。 phoneWindow和windowManager都拿着DecorView。

在handleResumeActivity, 调用windowmanagerImpl的addView方法，传入decorView.
然后进入WindowManagerGlobal的一个实例，也是addView方法，这里会构造ViewRootImpl类，调用viewRootImpl的setView方法。

ViewRootImpl拿到view之后，检查是否主线程，然后并不是马上performTraversals，而是向Choreographer注册，Choreographer通知viewrootimpl开始布局, 布局完成后通过binder连接windowMangerService

在performTraversals中，就会调用viewTreeObserver的listener。

点击事件：传递到viewRootImpl，root把事件放到handler,并且message为异步消息，就是有barrier也会执行。回调到主线程，就会传到Activity，window,decorView, 如果都没处理，那就交给Activity处理。



windowmanagerService会把可显示的寬高传回来，而decorView是matchParent的，所以decorView得到的measurespec是exactly的，然后就会调用decorVIew的measure方法

在measure里，会先判断，如果有强制layout的flag，或者传入的measureSpec和之前的不一样，就会调用onMeasure
对于viewGroup, 有measureChildWithMargins辅助方法，主要问题是确定子view的measureSpec，也不難，就是根据父view的measureSpec确定子view的。

requestLayout: 向父view调用requestLayout，把自己的flag加上force_layout，一直向上传到viewRootImpl

invalidate: 为自己设置标置位，把需要重绘的区域传给父view，父view会在自己的坐标系中把区域转变为自己的区域，向上一直传到viewRootImpl，触发重绘。


